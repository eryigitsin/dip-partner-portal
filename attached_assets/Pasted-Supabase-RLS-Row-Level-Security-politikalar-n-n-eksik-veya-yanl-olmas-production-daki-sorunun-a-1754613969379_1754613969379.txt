Supabase RLS (Row Level Security) politikalarƒ±nƒ±n eksik veya yanlƒ±≈ü olmasƒ± production'daki sorunun ana nedeni olabilir. ƒ∞≈üte bildirim sisteminiz i√ßin gerekli Supabase RLS politikalarƒ±:
üìã Notifications Tablosu i√ßin RLS Politikalarƒ±
1. RLS'i Etkinle≈ütirin
sql-- RLS'i aktif et
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
2. Kullanƒ±cƒ±lar Kendi Bildirimlerini G√∂rebilsin
sql-- Policy: Users can view their own notifications
CREATE POLICY "Users can view own notifications" 
ON notifications 
FOR SELECT 
USING (
  auth.uid()::text = user_id::text 
  OR 
  auth.uid() IN (
    SELECT id::text FROM users WHERE id = notifications.user_id
  )
);
3. Kullanƒ±cƒ±lar Kendi Bildirimlerini G√ºncelleyebilsin
sql-- Policy: Users can update their own notifications (mark as read)
CREATE POLICY "Users can update own notifications" 
ON notifications 
FOR UPDATE 
USING (
  auth.uid()::text = user_id::text
  OR 
  auth.uid() IN (
    SELECT id::text FROM users WHERE id = notifications.user_id
  )
)
WITH CHECK (
  auth.uid()::text = user_id::text
  OR 
  auth.uid() IN (
    SELECT id::text FROM users WHERE id = notifications.user_id
  )
);
4. Sistem/Admin Bildirim Olu≈üturabilsin
sql-- Policy: Service role and admins can insert notifications
CREATE POLICY "Service role can insert notifications" 
ON notifications 
FOR INSERT 
WITH CHECK (
  -- Service role her zaman ekleyebilir
  auth.jwt()->>'role' = 'service_role'
  OR 
  -- Admin kullanƒ±cƒ±lar ekleyebilir
  EXISTS (
    SELECT 1 FROM users 
    WHERE users.id::text = auth.uid()::text 
    AND users.user_type = 'admin'
  )
);
5. Admin T√ºm Bildirimleri G√∂rebilsin
sql-- Policy: Admins can view all notifications
CREATE POLICY "Admins can view all notifications" 
ON notifications 
FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE users.id::text = auth.uid()::text 
    AND users.user_type = 'admin'
  )
);
üîê Users Tablosu i√ßin RLS Politikalarƒ±
sql-- Users tablosu i√ßin RLS'i etkinle≈ütir
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Kullanƒ±cƒ±lar kendi profillerini g√∂rebilsin
CREATE POLICY "Users can view own profile" 
ON users 
FOR SELECT 
USING (
  id::text = auth.uid()::text
  OR
  -- Public profiles i√ßin
  true
);

-- Kullanƒ±cƒ±lar kendi profillerini g√ºncelleyebilsin
CREATE POLICY "Users can update own profile" 
ON users 
FOR UPDATE 
USING (id::text = auth.uid()::text)
WITH CHECK (id::text = auth.uid()::text);
üõ†Ô∏è Supabase Auth Session Y√∂netimi
Backend Konfig√ºrasyonu
typescript// server/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

// Service Role Client - Backend i√ßin (RLS bypass)
export const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!, // Service role key kullan
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);

// Public Client - Frontend auth kontrol√º i√ßin
export const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);
Notification Service G√ºncelleme
typescript// server/notification-service.ts
import { supabaseAdmin } from './lib/supabase';

export class NotificationService {
  async createNotification(notification: InsertNotification): Promise<void> {
    try {
      // Service role client kullan (RLS bypass)
      const { error } = await supabaseAdmin
        .from('notifications')
        .insert(notification);
      
      if (error) {
        console.error('Supabase error:', error);
        throw error;
      }
    } catch (error) {
      console.error('Error creating notification:', error);
    }
  }

  async getUserNotifications(userId: number, page: number = 1, limit: number = 20) {
    try {
      const offset = (page - 1) * limit;
      
      // User client kullan (RLS aktif)
      const { data, error, count } = await supabase
        .from('notifications')
        .select('*', { count: 'exact' })
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);
      
      if (error) {
        console.error('Supabase error:', error);
        throw error;
      }

      return {
        notifications: data || [],
        totalCount: count || 0,
        hasMore: (offset + limit) < (count || 0)
      };
    } catch (error) {
      console.error('Error fetching notifications:', error);
      return { notifications: [], totalCount: 0, hasMore: false };
    }
  }
}
Auth Middleware G√ºncelleme
typescript// server/middleware/auth.ts
import { supabase } from '../lib/supabase';

export async function authenticateUser(req: any, res: any, next: any) {
  try {
    // Supabase session token'ƒ± al
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      // Cookie'den kontrol et
      const sessionCookie = req.cookies['sb-access-token'];
      if (!sessionCookie) {
        return res.status(401).json({ error: 'No session' });
      }
    }

    // Supabase ile verify et
    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error || !user) {
      return res.status(401).json({ error: 'Invalid session' });
    }

    // User'ƒ± request'e ekle
    req.user = user;
    req.userId = user.id;
    
    next();
  } catch (error) {
    console.error('Auth error:', error);
    res.status(401).json({ error: 'Authentication failed' });
  }
}
üîç Debug ve Test Queries
RLS Politikalarƒ±nƒ± Kontrol Et
sql-- Mevcut politikalarƒ± listele
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies 
WHERE tablename IN ('notifications', 'users');

-- RLS durumunu kontrol et
SELECT 
  schemaname,
  tablename,
  rowsecurity,
  forcerowsecurity
FROM pg_tables 
WHERE tablename IN ('notifications', 'users');
Test Query'leri
sql-- Service role ile test (RLS bypass)
SET ROLE postgres;
SELECT COUNT(*) FROM notifications;

-- Anon role ile test (RLS aktif)
SET ROLE anon;
SELECT COUNT(*) FROM notifications; -- 0 d√∂nmeli

-- Authenticated user olarak test
SET ROLE authenticated;
SET request.jwt.claim.sub = 'user-id-here';
SELECT * FROM notifications WHERE user_id = 'user-id-here';
‚ö° Hƒ±zlƒ± √á√∂z√ºm Script
T√ºm politikalarƒ± tek seferde eklemek i√ßin:
sql-- Notifications tablosu i√ßin
BEGIN;

ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own notifications" ON notifications;
DROP POLICY IF EXISTS "Users can update own notifications" ON notifications;
DROP POLICY IF EXISTS "Service role can insert notifications" ON notifications;
DROP POLICY IF EXISTS "Admins can view all notifications" ON notifications;

CREATE POLICY "Users can view own notifications" 
ON notifications FOR SELECT 
USING (auth.uid()::text = user_id::text);

CREATE POLICY "Users can update own notifications" 
ON notifications FOR UPDATE 
USING (auth.uid()::text = user_id::text);

CREATE POLICY "Service role can insert notifications" 
ON notifications FOR INSERT 
WITH CHECK (true); -- Service role her zaman ekleyebilir

CREATE POLICY "Admins can view all notifications" 
ON notifications FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE users.id::text = auth.uid()::text 
    AND users.user_type = 'admin'
  )
);

-- Users tablosu i√ßin
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view profiles" ON users;
DROP POLICY IF EXISTS "Users can update own profile" ON users;

CREATE POLICY "Users can view profiles" 
ON users FOR SELECT 
USING (true); -- Herkes profilleri g√∂rebilir

CREATE POLICY "Users can update own profile" 
ON users FOR UPDATE 
USING (id::text = auth.uid()::text);

COMMIT;
üß™ Frontend Auth Header Ekleme
typescript// client/lib/queryClient.ts
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export async function apiRequest(method: string, url: string, body?: any) {
  // Supabase session'ƒ± al
  const { data: { session } } = await supabase.auth.getSession();
  
  const headers: any = {
    'Content-Type': 'application/json',
  };
  
  // Auth token ekle
  if (session?.access_token) {
    headers['Authorization'] = `Bearer ${session.access_token}`;
  }
  
  const response = await fetch(url, {
    method,
    credentials: 'include',
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });
  
  return response;
}